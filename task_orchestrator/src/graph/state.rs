//! Graph state for the task orchestrator.
//!
//! The GraphState carries state between graph nodes while orchestrating a single
//! task. It includes the current task snapshot and any routing decision emitted
//! by classifier nodes. This type lives in the orchestrator crate and is kept
//! framework-agnostic.
//!
//! Revision History
//! - 2025-11-23T17:30:00Z @AI: Add subtasks field for Phase 3 Sprint 7 decomposition support.
//! - 2025-11-12T21:45:00Z @AI: Add GraphState struct with constructor and unit tests (Phase 5).

/// State container threaded through the graph execution for one task.
#[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
pub struct GraphState {
    /// The task being orchestrated.
    pub task: task_manager::domain::task::Task,
    /// Optional routing decision emitted by classifier nodes.
    pub routing_decision: std::option::Option<std::string::String>,
    /// Optional subtasks generated by decomposition node.
    pub subtasks: std::option::Option<std::vec::Vec<task_manager::domain::task::Task>>,
}

impl GraphState {
    /// Creates a new GraphState initialized with a task and no routing decision or subtasks.
    pub fn new(task: task_manager::domain::task::Task) -> Self {
        GraphState {
            task,
            routing_decision: std::option::Option::None,
            subtasks: std::option::Option::None,
        }
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_graph_state_new_initializes_none() {
        let ai = transcript_extractor::domain::action_item::ActionItem {
            title: std::string::String::from("Title"),
            assignee: std::option::Option::None,
            due_date: std::option::Option::None,
        };
        let task = task_manager::domain::task::Task::from_action_item(&ai, std::option::Option::None);
        let gs = super::GraphState::new(task.clone());
        std::assert!(gs.routing_decision.is_none());
        std::assert_eq!(gs.task.id, task.id);
    }
}
